<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js æ²‰æµ¸å¼å¡”ç½—æŠ½å¡</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            /* æ·±è“è‰²èƒŒæ™¯ï¼Œé…åˆæ˜Ÿç©ºæ•ˆæœ */
            font-family: "Microsoft YaHei", sans-serif;
            color: #eee;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* é¡¶éƒ¨é¢æ¿ */
        .top-bar {
            padding: 20px;
            /* å†…è¾¹è·ï¼Œ20pxè¡¨ç¤ºä¸Šä¸‹å·¦å³å‡ä¸º20åƒç´  */
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), transparent);
            /* èƒŒæ™¯ç®€å†™ï¼Œlinear-gradientè¡¨ç¤ºçº¿æ€§æ¸å˜é¢œè‰² */
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            /* äº¤å‰è½´å¯¹é½ï¼Œflex-startè¡¨ç¤ºé¡¶éƒ¨å¯¹é½ */
            pointer-events: auto;
            /* autoè¡¨ç¤ºæ¢å¤é¼ æ ‡äº‹ä»¶å“åº” */
        }

        .status-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border: 1px solid #444;
            /* è¾¹æ¡†ï¼Œ1pxå®½å®çº¿ï¼Œé¢œè‰²#444 */
            border-radius: 8px;
            /* åœ†è§’åŠå¾„ï¼Œ8pxè¡¨ç¤ºåœ†è§’çš„å¼¯æ›²ç¨‹åº¦ */
            backdrop-filter: blur(5px);
            /* èƒŒæ™¯æ»¤é•œï¼Œblur(5px)è¡¨ç¤ºèƒŒæ™¯é«˜æ–¯æ¨¡ç³Š5åƒç´  */
            min-width: 200px;
            /* æœ€å°å®½åº¦ï¼Œé™åˆ¶å…ƒç´ æœ€å°ä¸º200px */
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
            /* å­—ä½“å¤§å°ï¼Œ1.2remè¡¨ç¤ºç›¸å¯¹äºæ ¹å…ƒç´ å­—ä½“çš„1.2å€ */
            color: #d4af37;
            text-shadow: 0 0 10px #d4af37;
            /* æ–‡å­—é˜´å½±ï¼Œå‚æ•°ä¾æ¬¡ä¸ºæ°´å¹³åç§»ã€å‚ç›´åç§»ã€æ¨¡ç³ŠåŠå¾„ã€é¢œè‰² */
        }

        .status-text {
            color: #fff;
            font-size: 0.9rem;
            margin-bottom: 5px;
            /* ä¸‹å¤–è¾¹è·ï¼Œ5px */
        }

        .mode-switch {
            cursor: pointer;
            /* é¼ æ ‡æ ·å¼ï¼Œpointerè¡¨ç¤ºæ‰‹å‹å…‰æ ‡ */
            padding: 5px 12px;
            background: #333;
            border: 1px solid #666;
            color: white;
            border-radius: 4px;
            font-size: 0.8rem;
            transition: 0.2s;
            /* è¿‡æ¸¡æ•ˆæœï¼Œ0.2sè¡¨ç¤ºæ‰€æœ‰å¯è¿‡æ¸¡å±æ€§å˜åŒ–è€—æ—¶0.2ç§’ */
        }

        .mode-switch:hover {
            background: #d4af37;
            color: #000;
        }

        /* æ²‰æµ¸æ¨¡å¼ */
        body.immersive #ui-layer {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        body.immersive #cursor-debug {
            display: none !important;
        }

        body.immersive #loader {
            display: none !important;
        }

        body.immersive #card-name-reveal {
            display: block !important;
        }

        /* å†å²è®°å½• */
        #history-panel {
            width: 260px;
            max-height: 40vh;
            /* æœ€å¤§é«˜åº¦ï¼Œé™åˆ¶å…ƒç´ æœ€å¤§ä¸ºè§†å£é«˜åº¦çš„40% */
            overflow-y: auto;
            /* å‚ç›´æº¢å‡ºï¼Œautoè¡¨ç¤ºå†…å®¹è¶…é«˜æ—¶è‡ªåŠ¨æ˜¾ç¤ºæ»šåŠ¨æ¡ */
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            pointer-events: auto;
            font-size: 0.9rem;
        }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        #history-panel::-webkit-scrollbar {
            width: 6px;
        }

        #history-panel::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 3px;
        }

        .history-item {
            margin-bottom: 8px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            animation: fadeIn 0.5s ease;
            /* åŠ¨ç”»ï¼ŒfadeInä¸ºåŠ¨ç”»åï¼Œ0.5sæ—¶é•¿ï¼Œeaseä¸ºç¼“åŠ¨å‡½æ•° */
        }

        .history-name {
            color: #d4af37;
            font-weight: bold;
            /* å­—ä½“ç²—ç»†ï¼Œboldè¡¨ç¤ºåŠ ç²— */
        }

        .history-meaning {
            font-size: 0.8rem;
            color: #aaa;
            margin-top: 2px;
            /* ä¸Šå¤–è¾¹è· */
        }

        @keyframes fadeIn {

            /* å…³é”®å¸§å®šä¹‰ï¼Œç”¨äºå®šä¹‰åŠ¨ç”»åºåˆ— */
            from {
                opacity: 0;
                transform: translateX(20px);
                /* å˜æ¢ï¼ŒtranslateXè¡¨ç¤ºæ°´å¹³ä½ç§» */
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* åº•éƒ¨æç¤º */
        .bottom-hint {
            text-align: center;
            padding: 20px;
            text-shadow: 0 0 5px black;
            font-size: 1.1rem;
            opacity: 0.8;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
        }

        /* åŠ è½½é®ç½© */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #d4af37;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* éšè—è§†é¢‘å…ƒç´  */
        #input-video {
            display: none;
        }

        /* ç»“æœå±•ç¤ºå¤§å­— */
        #result-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            width: 80%;
        }

        .result-title {
            font-size: 3rem;
            color: #d4af37;
            text-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
            margin: 0;
        }

        .result-sub {
            font-size: 1.4rem;
            color: #fff;
            margin-top: 15px;
            text-shadow: 0 0 10px #000;
            line-height: 1.4;
            /* è¡Œé«˜ï¼Œ1.4å€å­—ä½“å¤§å° */
        }

        /* ç‰Œåå‡åæ—¶çš„æ˜¾ç¤ºæ•ˆæœ */
        #card-name-reveal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: bold;
            color: transparent;
            background: linear-gradient(135deg, #d4af37 0%, #f4e4ba 25%, #d4af37 50%, #aa8c2c 75%, #d4af37 100%);
            background-size: 200% 200%;
            /* èƒŒæ™¯å°ºå¯¸ï¼Œæ”¾å¤§èƒŒæ™¯ä»¥æ”¯æŒæµå…‰æ•ˆæœ */
            -webkit-background-clip: text;
            /* èƒŒæ™¯è£å‰ªï¼ˆWebkitå†…æ ¸ï¼‰ï¼Œtextè¡¨ç¤ºèƒŒæ™¯ä»…å¡«å……æ–‡å­—åŒºåŸŸ */
            background-clip: text;
            /* èƒŒæ™¯è£å‰ªï¼Œæ ‡å‡†å±æ€§ */
            text-shadow: 0 0 40px rgba(212, 175, 55, 0.8), 0 0 80px rgba(212, 175, 55, 0.4);
            opacity: 0;
            pointer-events: none;
            z-index: 50;
            letter-spacing: 8px;
            /* å­—é—´è·ï¼Œå¢åŠ å­—ç¬¦ä¹‹é—´çš„è·ç¦» */
        }

        #card-name-reveal.show {
            animation: revealName 2.5s ease-out forwards, shimmer 2s linear infinite;
        }

        @keyframes revealName {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
                filter: blur(20px);
            }

            30% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1);
                filter: blur(0);
            }

            50% {
                transform: translate(-50%, -50%) scale(1);
            }

            80% {
                opacity: 1;
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.2);
            }
        }

        /* å±•ç¤ºæ—¶ä¿æŒæ˜¾ç¤º */
        #card-name-reveal.showing {
            animation: revealIn 0.8s ease-out forwards, shimmer 2s linear infinite;
        }

        @keyframes revealIn {
            0% {
                opacity: 0;
                transform: translate(-50%, -80%) scale(0.5);
                filter: blur(10px);
            }

            100% {
                opacity: 1;
                transform: translate(-50%, -80%) scale(1);
                filter: blur(0);
            }
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
                /* èƒŒæ™¯ä½ç½®ï¼Œæ”¹å˜èƒŒæ™¯ä½ç½®å®ç°æµå…‰åŠ¨ç”» */
            }

            100% {
                background-position: -200% 0;
            }
        }

        /* è°ƒè¯•å‡†æ˜Ÿ */
        #cursor-debug {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            /* ç¦ç”¨å…ƒç´ çš„é¼ æ ‡äº‹ä»¶å“åº”ï¼Œä½¿ç‚¹å‡»ç©¿é€åˆ°ä¸‹å±‚å…ƒç´  */
            z-index: 20;
            /* è®¾ç½®å…ƒç´ çš„å †å é¡ºåºä¸º20ï¼Œæ•°å€¼è¶Šé«˜è¶Šé ä¸Šï¼ˆä½äºåŠ è½½é®ç½©z-index:100ï¼Œé«˜äºèƒŒæ™¯z-index:1ï¼‰ */
            display: none;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
            /* ç›’å­é˜´å½±ï¼Œå‚æ•°ä¾æ¬¡ä¸ºæ°´å¹³åç§»ã€å‚ç›´åç§»ã€æ¨¡ç³ŠåŠå¾„ã€é¢œè‰² */
            transition: background-color 0.1s;
        }

        /* æ‘„åƒå¤´å®æ—¶é¢„è§ˆæ¡† */
        #camera-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            border: 2px solid #d4af37;
            border-radius: 8px;
            overflow: hidden;
            z-index: 90;
            /* ä½äº loading ä½†é«˜äºèƒŒæ™¯ */
            background: #000;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
        }

        #output-canvas {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            /* é•œåƒæ˜¾ç¤º */
        }

        #gesture-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #0f0;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            border-radius: 4px;
        }
    </style>

    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>

    <div id="loader">
        <div class="spinner"></div>
        <p style="margin-top:20px; color:#aaa;">æ­£åœ¨è¿æ¥å‘½è¿ä¹‹çº¿...</p>
    </div>

    <div id="canvas-container"></div>
    <div id="cursor-debug"></div>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="status-box">
                <h1>ğŸ”® æ²‰æµ¸å¼å¡”ç½—</h1>
                <div id="status-text" class="status-text">åˆå§‹åŒ–ä¸­...</div>
                <button id="mode-btn" class="mode-switch">åˆ‡æ¢è¾“å…¥æ¨¡å¼</button>
                <button id="immersive-btn" class="mode-switch" style="margin-left:5px;">æ²‰æµ¸æ¨¡å¼ (I)</button>
            </div>
            <div id="history-panel">
                <div
                    style="text-align:center; border-bottom:1px solid #555; margin-bottom:5px; padding-bottom:5px; color:#d4af37;">
                    ğŸ“œ å‘½è¿è®°å½•</div>
                <div id="history-content"></div>
            </div>
        </div>

        <div id="result-overlay">
            <h2 class="result-title" id="res-name"></h2>
            <div class="result-sub" id="res-meaning"></div>
        </div>

        <div class="bottom-hint" id="guide-text">
            åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«ä¸­...
        </div>
    </div>

    <div id="card-name-reveal"></div>

    <div id="camera-preview">
        <canvas id="output-canvas"></canvas>
        <div id="gesture-label">æœªæ£€æµ‹</div>
    </div>

    <video id="input-video"></video>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // 1. æ•°æ®é…ç½® (22å¼ å¤§é˜¿å¡çº³)
        // ==========================================
        const TAROT_DATA = [
            { name: "0 æ„šäºº", u: "æ–°çš„å¼€å§‹ï¼Œå†’é™©ï¼Œå¤©çœŸ", r: "é²è½ï¼Œè½»ç‡ï¼Œé£é™©", imgId: 0 },
            { name: "I é­”æœ¯å¸ˆ", u: "åˆ›é€ åŠ›ï¼ŒæŠ€èƒ½ï¼Œæ„å¿—åŠ›", r: "æ¬ºéª—ï¼Œæ²Ÿé€šä¸ç•…", imgId: 1 },
            { name: "II å¥³ç¥­å¸", u: "ç›´è§‰ï¼Œæ½œæ„è¯†ï¼Œç¥ç§˜", r: "å‹æŠ‘ï¼Œæƒ…ç»ªä¸ç¨³å®š", imgId: 2 },
            { name: "III çš‡å", u: "ä¸°é¥¶ï¼Œæ¯æ€§ï¼Œè‡ªç„¶", r: "ä¾èµ–ï¼Œåˆ›é€ åŠ›å—é˜»", imgId: 3 },
            { name: "IV çš‡å¸", u: "æƒå¨ï¼Œç»“æ„ï¼Œæ§åˆ¶", r: "æš´æ”¿ï¼ŒåƒµåŒ–ï¼Œå†·é…·", imgId: 4 },
            { name: "V æ•™çš‡", u: "ä¼ ç»Ÿï¼Œä¿¡ä»°ï¼ŒæŒ‡å¼•", r: "åå›ï¼Œè™šä¼ªï¼Œé™åˆ¶", imgId: 5 },
            { name: "VI æ‹äºº", u: "çˆ±ï¼Œå’Œè°ï¼Œé€‰æ‹©", r: "ä¸å¹³è¡¡ï¼Œåˆ†ç¦»", imgId: 6 },
            { name: "VII æˆ˜è½¦", u: "èƒœåˆ©ï¼Œæ„å¿—ï¼Œæ§åˆ¶", r: "å¤±æ§ï¼Œæ”»å‡»æ€§", imgId: 7 },
            { name: "VIII åŠ›é‡", u: "å‹‡æ°”ï¼Œè€å¿ƒï¼ŒåŒæƒ…", r: "è½¯å¼±ï¼Œè‡ªæˆ‘æ€€ç–‘", imgId: 8 },
            { name: "IX éšå£«", u: "å†…çœï¼Œå­¤ç‹¬ï¼ŒæŒ‡å¼•", r: "å­¤ç«‹ï¼Œè¿·å¤±", imgId: 9 },
            { name: "X å‘½è¿ä¹‹è½®", u: "æ”¹å˜ï¼Œå‘¨æœŸï¼Œå‘½è¿", r: "åè¿æ°”ï¼ŒæŠµæŠ—æ”¹å˜", imgId: 10 },
            { name: "XI æ­£ä¹‰", u: "å…¬å¹³ï¼ŒçœŸç†ï¼Œæ³•å¾‹", r: "ä¸å…¬ï¼Œåè§", imgId: 11 },
            { name: "XII å€’åŠäºº", u: "ç‰ºç‰²ï¼Œæ–°è§†è§’ï¼Œç­‰å¾…", r: "æ— è°“ç‰ºç‰²ï¼Œæ‹–å»¶", imgId: 12 },
            { name: "XIII æ­»ç¥", u: "ç»“æŸï¼Œè½¬å˜ï¼Œé‡ç”Ÿ", r: "åœæ»ï¼Œææƒ§æ”¹å˜", imgId: 13 },
            { name: "XIV èŠ‚åˆ¶", u: "å¹³è¡¡ï¼Œé€‚åº¦ï¼Œè€å¿ƒ", r: "å¤±è¡¡ï¼Œæç«¯", imgId: 14 },
            { name: "XV æ¶é­”", u: "æŸç¼šï¼Œç‰©è´¨ä¸»ä¹‰", r: "é‡Šæ”¾ï¼Œæ‰“ç ´æ·é”", imgId: 15 },
            { name: "XVI é«˜å¡”", u: "çªå˜ï¼Œç¾éš¾ï¼Œå¯ç¤º", r: "é¿å…ç¾éš¾ï¼Œææƒ§", imgId: 16 },
            { name: "XVII æ˜Ÿæ˜Ÿ", u: "å¸Œæœ›ï¼Œçµæ„Ÿï¼Œå¹³é™", r: "ç»æœ›ï¼Œç¼ºä¹ä¿¡å¿ƒ", imgId: 17 },
            { name: "XVIII æœˆäº®", u: "å¹»è§‰ï¼Œææƒ§ï¼Œæ½œæ„è¯†", r: "é‡Šæ”¾ææƒ§ï¼Œæ¸…æ™°", imgId: 18 },
            { name: "XIX å¤ªé˜³", u: "å¿«ä¹ï¼ŒæˆåŠŸï¼Œæ´»åŠ›", r: "æ‚²ä¼¤ï¼Œæš‚æ—¶å—é˜»", imgId: 19 },
            { name: "XX å®¡åˆ¤", u: "å¤æ´»ï¼Œè§‰é†’ï¼Œå®½æ•", r: "è‡ªæˆ‘æ€€ç–‘ï¼Œæ‹’ç»æ”¹å˜", imgId: 20 },
            { name: "XXI ä¸–ç•Œ", u: "å®Œæˆï¼Œæ•´åˆï¼Œæ—…è¡Œ", r: "æœªå®Œæˆï¼Œç¼ºä¹é—­ç¯", imgId: 21 }
        ];

        // OSS å›¾ç‰‡è·¯å¾„é…ç½®
        const IMG_BASE_URL = "https://raw.githubusercontent.com/dowsonmicic/Tarot_butterfly/refs/heads/images/docs/";
        const RWS_MAP = [
            "1.jpg", "2.jpg", "3.jpg", "4.jpg", "5.jpg", "6.jpg",
            "7.jpg", "8.jpg", "9.jpg", "10.jpg", "11.jpg", "12.jpg",
            "13.jpg", "14.jpg", "15.jpg", "16.jpg", "17.jpg", "18.jpg",
            "19.jpg", "20.jpg", "21.jpg", "22.jpg"
        ];

        // OSS ç‰ŒèƒŒå›¾ç‰‡
        const BACK_IMG_URL = IMG_BASE_URL + "bm.jpg";

        // ==========================================
        // 2. Three.js åœºæ™¯åˆå§‹åŒ–
        // ==========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.03); // æ·±è“è‰²èƒŒæ™¯é›¾åŒ–ï¼Œæ›´åƒå®‡å®™æ·±å¤„

        // ==========================================
        // åŠ¨æ€æ˜Ÿç©ºèƒŒæ™¯ç³»ç»Ÿ
        // ==========================================
        class Starfield {
            constructor() {
                this.count = 2000;
                this.geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.count * 3);
                const colors = new Float32Array(this.count * 3);
                const sizes = new Float32Array(this.count);

                for (let i = 0; i < this.count; i++) {
                    // åœ¨å¤§èŒƒå›´å†…éšæœºåˆ†å¸ƒæ˜Ÿæ˜Ÿ
                    positions[i * 3] = (Math.random() - 0.5) * 100;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 50 - 20;

                    // æ˜Ÿæ˜Ÿé¢œè‰²ï¼šä¸»è¦æ˜¯ç™½è‰²ï¼Œå¸¦ä¸€ç‚¹è“/é»„åç§»
                    const r = 0.8 + Math.random() * 0.2;
                    const g = 0.8 + Math.random() * 0.2;
                    const b = 0.9 + Math.random() * 0.1;
                    colors[i * 3] = r;
                    colors[i * 3 + 1] = g;
                    colors[i * 3 + 2] = b;

                    sizes[i] = Math.random() * 0.15 + 0.05;
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                this.material = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });

                this.mesh = new THREE.Points(this.geometry, this.material);
                scene.add(this.mesh);
            }

            update() {
                const positions = this.geometry.attributes.position.array;
                const time = Date.now() * 0.0005;

                for (let i = 0; i < this.count; i++) {
                    // è®©æ˜Ÿæ˜Ÿç¼“æ…¢æ—‹è½¬æˆ–ç§»åŠ¨
                    positions[i * 3 + 2] += 0.01; // ç¼“æ…¢å‘å±å¹•ç§»åŠ¨
                    if (positions[i * 3 + 2] > 20) {
                        positions[i * 3 + 2] = -30; // å¾ªç¯
                    }
                }
                this.geometry.attributes.position.needsUpdate = true;

                // æ˜Ÿæ˜Ÿé—ªçƒæ•ˆæœ
                this.material.opacity = 0.6 + Math.sin(time) * 0.2;
            }
        }
        const starfield = new Starfield();

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffd700, 1.0);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);
        const pointLight = new THREE.PointLight(0xaa88ff, 0.8);
        pointLight.position.set(-5, 2, 3);
        scene.add(pointLight);

        // çº¹ç†åŠ è½½å™¨é…ç½®
        const textureLoader = new THREE.TextureLoader();
        textureLoader.crossOrigin = 'anonymous'; // å¼€å¯è·¨åŸŸæ”¯æŒï¼Œå…è®¸ä» OSS åŠ è½½å›¾ç‰‡ç´ æ

        // é¢„åŠ è½½ç‰ŒèƒŒ
        const backTexture = textureLoader.load(BACK_IMG_URL);

        // ==========================================
        // 3. æ¸¸æˆçŠ¶æ€ä¸é€»è¾‘
        // ==========================================
        let gameState = {
            mode: 'HAND', // 'HAND' or 'MOUSE'
            cardMeshes: [], // æ‰€æœ‰22å¼ ç‰Œçš„mesh
            cardDataList: [], // æ¯å¼ ç‰Œçš„æ•°æ®ï¼ˆå«æ­£é€†ä½ï¼‰
            scrollOffset: 0, // æ°´å¹³æ»šåŠ¨åç§»
            scrollSpeed: 0.07, // åŸºç¡€æ»šåŠ¨é€Ÿåº¦ï¼ˆé¼ æ ‡æ¨¡å¼é»˜è®¤é€Ÿåº¦ï¼‰
            currentSpeed: 0.10, // å½“å‰å®æ—¶æ»šåŠ¨é€Ÿåº¦ï¼ˆæ‰‹åŠ¿æ¨¡å¼ä¸‹åŠ¨æ€å˜åŒ–ï¼‰
            phase: 'IDLE', // IDLE, SCROLLING, SHOWING, FLIPPING, LOADING
            selectedMesh: null, // è¢«é€‰ä¸­æ”¾å¤§å±•ç¤ºçš„ç‰Œ
            selectedData: null, // è¢«é€‰ä¸­ç‰Œçš„æ•°æ®
            selectedIndex: -1, // è¢«é€‰ä¸­ç‰Œç´¢å¼•
            cursor: { x: 0, y: 0 },
            isHandOpen: false, // æ‰‹æŒå¼ å¼€
            openness: 0, // æ‰‹æŒå¼ å¼€ç¨‹åº¦ (0-1)
            isFist: false, // æ¡æ‹³
            wasFist: false, // ä¸Šä¸€å¸§æ˜¯å¦æ¡æ‹³
            isDragging: false, // é¼ æ ‡æ‹–åŠ¨
            // æ‰‹åŠ¿é˜²æŠ–
            fistCounter: 0, // æ¡æ‹³è®¡æ•°å™¨
            openCounter: 0, // å¼ å¼€è®¡æ•°å™¨
            gestureThreshold: 5, // éœ€è¦è¿ç»­å‡ å¸§æ‰ç¡®è®¤

            // æ¡æ‹³ä¿æŒé€»è¾‘ï¼ˆæ–°å¢ï¼‰
            isHoldingFist: false, // æ˜¯å¦æ­£åœ¨ä¿æŒæ¡æ‹³
            fistHoldStartTime: 0, // æ¡æ‹³å¼€å§‹æ—¶é—´æˆ³
            fistHoldDuration: 2000 // éœ€è¦ä¿æŒçš„æ¯«ç§’æ•° (2ç§’)
        };

        // è½®æ’­å‚æ•°
        const CARD_COUNT = 22;
        const CARD_SPACING = 3.2; // ç‰Œé—´è·
        const TOTAL_WIDTH = CARD_COUNT * CARD_SPACING; // æ€»å®½åº¦ï¼ˆå¾ªç¯ï¼‰

        const raycaster = new THREE.Raycaster();
        const mouseVector = new THREE.Vector2();

        // UI å¼•ç”¨
        const guideText = document.getElementById('guide-text');
        const statusText = document.getElementById('status-text');
        const historyContent = document.getElementById('history-content');
        const cursorDebug = document.getElementById('cursor-debug');
        const resTitle = document.getElementById('res-name');
        const resSub = document.getElementById('res-meaning');
        const resOverlay = document.getElementById('result-overlay');

        // ==========================================
        // 4. å¡ç‰Œä¸ç²’å­ç³»ç»Ÿ
        // ==========================================

        // æ˜Ÿå…‰å‡åç²’å­ç³»ç»Ÿ (ä»£æ›¿åŸæœ¬çš„ç¢è£‚æ•ˆæœ)
        class StarlightEffect {
            constructor(position) {
                this.particlesCount = 2500;
                this.geometry = new THREE.BufferGeometry();
                const positions = [];
                const velocities = [];
                const colors = [];
                const life = [];

                const w = 4.0, h = 5.5;
                for (let i = 0; i < this.particlesCount; i++) {
                    // åˆå§‹ä½ç½®åœ¨ç‰Œçš„åŒºåŸŸå†…
                    positions.push(
                        position.x + (Math.random() - 0.5) * w,
                        position.y + (Math.random() - 0.5) * h,
                        position.z + (Math.random() - 0.5) * 0.2
                    );

                    // å‘ä¸Šå‡åçš„åˆé€Ÿåº¦
                    const speed = 0.02 + Math.random() * 0.05;
                    velocities.push(
                        (Math.random() - 0.5) * 0.02, // å·¦å³è½»å¾®æ™ƒåŠ¨
                        speed * 1.5 + 0.01,           // ä¸»è¦å‘ä¸Šç§»åŠ¨
                        (Math.random() - 0.5) * 0.02
                    );

                    // æ˜Ÿå…‰é¢œè‰²ï¼šé‡‘é»„è‰²ã€çº¯ç™½è‰²ã€æ·¡ç´«è‰²
                    const colorChoice = Math.random();
                    if (colorChoice < 0.5) {
                        colors.push(1.0, 0.9, 0.5); // æš–é‡‘è‰²
                    } else if (colorChoice < 0.8) {
                        colors.push(1.0, 1.0, 1.0); // çº¯ç™½æ˜Ÿå…‰
                    } else {
                        colors.push(0.9, 0.7, 1.0); // æ·¡ç´«è‰²
                    }

                    life.push(1.0 + Math.random() * 1.2);
                }

                this.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                this.geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
                this.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                this.geometry.setAttribute('life', new THREE.Float32BufferAttribute(life, 1));

                this.material = new THREE.PointsMaterial({
                    size: 0.12,
                    transparent: true,
                    opacity: 1,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.mesh = new THREE.Points(this.geometry, this.material);
                this.mesh.frustumCulled = false;
                this.startTime = Date.now();
                scene.add(this.mesh);
            }

            update() {
                const positions = this.geometry.attributes.position.array;
                const velocities = this.geometry.attributes.velocity.array;
                const lives = this.geometry.attributes.life.array;
                let alive = false;
                const elapsed = (Date.now() - this.startTime) * 0.001;

                for (let i = 0; i < this.particlesCount; i++) {
                    if (lives[i] > 0) {
                        alive = true;

                        // å‡åç§»åŠ¨
                        positions[i * 3] += velocities[i * 3];
                        positions[i * 3 + 1] += velocities[i * 3 + 1];
                        positions[i * 3 + 2] += velocities[i * 3 + 2];

                        // æ¨¡æ‹Ÿæ°”æµæ³¢åŠ¨
                        const wave = elapsed * 2 + i * 0.05;
                        positions[i * 3] += Math.sin(wave) * 0.005;
                        positions[i * 3 + 2] += Math.cos(wave) * 0.005;

                        // é€æ¸æ¶ˆå¤±
                        lives[i] -= 0.004;
                    }
                }

                this.material.opacity = Math.max(0, this.material.opacity - 0.004);
                this.geometry.attributes.position.needsUpdate = true;

                if (!alive || this.material.opacity <= 0) {
                    scene.remove(this.mesh);
                    this.geometry.dispose();
                    this.material.dispose();
                    return false;
                }
                return true;
            }
        }

        let starlights = [];

        // ç”Ÿæˆå…¨éƒ¨22å¼ ç‰Œçš„æ°´å¹³è½®æ’­
        function spawnAllCards() {
            gameState.phase = 'LOADING';
            statusText.innerText = "çŠ¶æ€: æ­£åœ¨å¬å”¤å‘½è¿ä¹‹ç‰Œ...";

            // æ¸…ç†æ—§ç‰Œ
            gameState.cardMeshes.forEach(mesh => {
                if (mesh) {
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                }
            });
            gameState.cardMeshes = [];
            gameState.cardDataList = [];
            gameState.scrollOffset = 0;
            gameState.selectedMesh = null;
            gameState.selectedData = null;

            // æ‰“ä¹±ç‰Œåº
            const shuffledIndices = Array.from({ length: 22 }, (_, i) => i);
            for (let i = shuffledIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledIndices[i], shuffledIndices[j]] = [shuffledIndices[j], shuffledIndices[i]];
            }

            let loadedCount = 0;

            shuffledIndices.forEach((cardId, index) => {
                const cardData = TAROT_DATA[cardId];
                const isReversed = Math.random() < 0.5;
                const imgUrl = IMG_BASE_URL + RWS_MAP[cardData.imgId];

                // ä¿å­˜ç‰Œæ•°æ®
                gameState.cardDataList[index] = { ...cardData, isReversed };

                textureLoader.load(
                    imgUrl,
                    (tex) => {
                        createCarouselCard(tex, index, isReversed);
                        loadedCount++;
                        if (loadedCount === CARD_COUNT) {
                            onAllCardsLoaded();
                        }
                    },
                    undefined,
                    (err) => {
                        console.warn("Image load failed for card " + cardId);
                        const placeholder = new THREE.CanvasTexture(createPlaceholderCanvas(cardData.name));
                        createCarouselCard(placeholder, index, isReversed);
                        loadedCount++;
                        if (loadedCount === CARD_COUNT) {
                            onAllCardsLoaded();
                        }
                    }
                );
            });
        }

        function createCarouselCard(frontTex, index, isReversed) {
            const geometry = new THREE.BoxGeometry(2.5, 4.0, 0.05);

            frontTex.colorSpace = THREE.SRGBColorSpace;
            backTexture.colorSpace = THREE.SRGBColorSpace;

            const sideMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 });
            const frontMat = new THREE.MeshStandardMaterial({ map: frontTex, roughness: 0.4, metalness: 0.1 });
            const backMat = new THREE.MeshStandardMaterial({ map: backTexture, roughness: 0.6 });

            // æ³¨æ„ï¼šæ­£é¢å’ŒèƒŒé¢ä½ç½®
            const materials = [sideMat, sideMat, sideMat, sideMat, frontMat, backMat];
            const mesh = new THREE.Mesh(geometry, materials);

            // å­˜å‚¨ç´¢å¼•å’Œæ­£é€†ä½ä¿¡æ¯
            mesh.userData = { index, isReversed, originalIndex: index, frontTex };

            // åˆå§‹ä½ç½®åœ¨ä¸‹æ–¹
            mesh.position.y = -10;
            mesh.position.z = -2;

            // é»˜è®¤æ˜¾ç¤ºèƒŒé¢ï¼ˆæ—‹è½¬180åº¦ï¼‰
            mesh.rotation.y = Math.PI;

            scene.add(mesh);
            gameState.cardMeshes[index] = mesh;
        }

        function onAllCardsLoaded() {
            let progress = 0;
            function intro() {
                progress += 0.025;
                const easeOut = 1 - Math.pow(1 - Math.min(progress, 1), 3);

                gameState.cardMeshes.forEach((mesh, i) => {
                    if (!mesh) return;
                    // æ°´å¹³æ’åˆ—
                    const targetX = (i - CARD_COUNT / 2) * CARD_SPACING;
                    mesh.position.x = targetX;
                    mesh.position.y = THREE.MathUtils.lerp(-10, 0, easeOut);
                    mesh.position.z = -2;

                    // æ­£é€†ä½
                    if (mesh.userData.isReversed) {
                        mesh.rotation.z = Math.PI;
                    }
                });

                if (progress < 1) {
                    requestAnimationFrame(intro);
                } else {
                    gameState.phase = 'IDLE';
                    resetUIForNewRound();
                }
            }
            intro();
        }

        function resetUIForNewRound() {
            resOverlay.style.opacity = 0;
            statusText.innerText = gameState.mode === 'HAND'
                ? "çŠ¶æ€: å¼ å¼€æ‰‹æŒå¼€å§‹æ»šåŠ¨"
                : "çŠ¶æ€: æŒ‰ä½å·¦é”®å¼€å§‹æ»šåŠ¨";
            guideText.innerText = gameState.mode === 'HAND'
                ? "ğŸ– å¼ å¼€=æ»šåŠ¨ | âœŠ æ¡æ‹³=æŠ½å– | æ¾å¼€=å‡å"
                : "ğŸ–± æŒ‰ä½=æ»šåŠ¨ | åŒå‡»=æŠ½å– | å†æ¬¡åŒå‡»=å‡å";
        }

        function createPlaceholderCanvas(text) {
            const c = document.createElement('canvas');
            c.width = 256; c.height = 400;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, 256, 400);
            ctx.strokeStyle = '#d4af37'; ctx.lineWidth = 10; ctx.strokeRect(5, 5, 246, 390);
            ctx.fillStyle = '#d4af37'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center';
            ctx.fillText(text, 128, 180);
            ctx.font = '16px Arial'; ctx.fillStyle = '#888';
            ctx.fillText("Image Unavailable", 128, 220);
            return c;
        }

        // æ›´æ–°æ°´å¹³æ»šåŠ¨
        function updateCarousel() {
            gameState.cardMeshes.forEach((mesh, i) => {
                if (!mesh) return;
                if (mesh === gameState.selectedMesh) return; // è¢«é€‰ä¸­çš„ç‰Œä¸å‚ä¸æ»šåŠ¨

                // è®¡ç®—å¾ªç¯ä½ç½®
                let baseX = (i - CARD_COUNT / 2) * CARD_SPACING;
                let x = baseX + gameState.scrollOffset;

                // å¾ªç¯å¤„ç†
                while (x > TOTAL_WIDTH / 2) x -= TOTAL_WIDTH;
                while (x < -TOTAL_WIDTH / 2) x += TOTAL_WIDTH;

                mesh.position.x = x;
                mesh.position.z = -2;

                // ä¸­é—´çš„ç‰Œç¨å¾®æ”¾å¤§å’Œå‰ç§»
                const distFromCenter = Math.abs(x);
                const scale = THREE.MathUtils.lerp(1.15, 0.9, Math.min(distFromCenter / 8, 1));
                const zOffset = THREE.MathUtils.lerp(1, 0, Math.min(distFromCenter / 8, 1));

                mesh.scale.lerp(new THREE.Vector3(scale, scale, scale), 0.15);
                mesh.position.z = THREE.MathUtils.lerp(mesh.position.z, -2 + zOffset, 0.15);
                mesh.position.y = THREE.MathUtils.lerp(mesh.position.y, 0, 0.1);
            });
        }

        // è·å–å½“å‰ä¸­é—´çš„ç‰Œ
        function getCenterCard() {
            let closest = null;
            let minDist = Infinity;
            gameState.cardMeshes.forEach((mesh, i) => {
                if (!mesh) return;
                const dist = Math.abs(mesh.position.x);
                if (dist < minDist) {
                    minDist = dist;
                    closest = { mesh, index: i, data: gameState.cardDataList[i] };
                }
            });
            return closest;
        }

        // ==========================================
        // 5. äº¤äº’æ ¸å¿ƒé€»è¾‘
        // ==========================================

        function updateInteraction() {
            if (gameState.cardMeshes.length === 0 || gameState.phase === 'LOADING') return;

            // ç¿»ç‰ŒåŠ¨ç”»æœŸé—´ä¸å“åº”äº¤äº’
            if (gameState.phase === 'FLIPPING') {
                gameState.wasFist = gameState.isFist;
                return;
            }

            // æ›´æ–°è½®æ’­ä½ç½®
            updateCarousel();

            // çŠ¶æ€æœºé€»è¾‘
            if (gameState.phase === 'IDLE' || gameState.phase === 'SCROLLING') {
                // å¼ å¼€æ‰‹/æŒ‰ä½é¼ æ ‡ = æ»šåŠ¨
                if (gameState.isHandOpen || gameState.isDragging) {
                    // åŠ¨æ€é€Ÿåº¦æ§åˆ¶ï¼š
                    // æ‰‹åŠ¿æ¨¡å¼ä½¿ç”¨è®¡ç®—å‡ºçš„ currentSpeedï¼ˆå–å†³äºæ‰‹å¼ å¼€ç¨‹åº¦ï¼‰
                    // é¼ æ ‡æ¨¡å¼ä½¿ç”¨å›ºå®šçš„ scrollSpeed
                    const speed = gameState.mode === 'HAND' ? gameState.currentSpeed : gameState.scrollSpeed;

                    gameState.scrollOffset += speed;
                    gameState.phase = 'SCROLLING';

                    // æ›´æ–°çŠ¶æ€æç¤ºæ–‡æ¡ˆï¼Œæ˜¾ç¤ºå½“å‰é€Ÿåº¦æ„ŸçŸ¥ï¼ˆä»…é™æ‰‹åŠ¿æ¨¡å¼ï¼‰
                    if (gameState.mode === 'HAND') {
                        const openPercent = Math.round(gameState.openness * 100);
                        statusText.innerText = `çŠ¶æ€: å‘½è¿ä¹‹è½®è½¬åŠ¨ä¸­... (å¼ å¼€åº¦: ${openPercent}%) æ¡æ‹³æŠ½å–!`;
                    } else {
                        statusText.innerText = "çŠ¶æ€: å‘½è¿ä¹‹è½®è½¬åŠ¨ä¸­... æ¡æ‹³æŠ½å–!";
                    }
                } else {
                    gameState.phase = 'IDLE';
                    if (gameState.mode === 'HAND') {
                        statusText.innerText = "çŠ¶æ€: å¼ å¼€æ‰‹æŒå¼€å§‹æ»šåŠ¨ (å¼ å¾—è¶Šå¼€ï¼Œæ»šå¾—è¶Šå¿«)";
                    }
                }

                // æ¡æ‹³ = æŠ½å–å½“å‰ç‰Œ
                if (gameState.isFist && !gameState.wasFist) {
                    selectCard();
                }
            }
            else if (gameState.phase === 'SHOWING') {
                // å±•ç¤ºä¸­ï¼Œæ¾å¼€æ‹³å¤´ = å‡å
                if (!gameState.isFist && gameState.wasFist) {
                    dismissCard();
                }
            }

            gameState.wasFist = gameState.isFist;
        }

        // æŠ½å–ç‰Œï¼ˆå¸¦ç¿»ç‰ŒåŠ¨ç”»ï¼‰
        function selectCard() {
            const center = getCenterCard();
            if (!center) return;

            gameState.phase = 'FLIPPING';
            gameState.selectedMesh = center.mesh;
            gameState.selectedData = center.data;
            gameState.selectedIndex = center.index;

            const mesh = center.mesh;
            const isRev = center.data.isReversed;

            // ç¿»ç‰ŒåŠ¨ç”»
            let flipProgress = 0;
            const startRotY = mesh.rotation.y; // åˆå§‹æ˜¯ Math.PIï¼ˆèƒŒé¢ï¼‰
            const targetRotY = 0; // ç¿»åˆ°æ­£é¢ï¼ˆæ— è®ºæ­£é€†ä½éƒ½è¦ç¿»åˆ°æ­£é¢ï¼‰
            const startPos = mesh.position.clone();
            const startScale = mesh.scale.x;
            const startRotZ = mesh.rotation.z;
            const targetRotZ = isRev ? Math.PI : 0; // é€†ä½åˆ™zè½´æ—‹è½¬180åº¦

            function flipAnimation() {
                flipProgress += 0.03;
                const ease = 1 - Math.pow(1 - Math.min(flipProgress, 1), 3);

                // ç¿»è½¬åˆ°æ­£é¢
                mesh.rotation.y = THREE.MathUtils.lerp(startRotY, targetRotY, ease);

                // é€†ä½æ—‹è½¬
                mesh.rotation.z = THREE.MathUtils.lerp(startRotZ, targetRotZ, ease);

                // ç§»åŠ¨åˆ°ä¸­å¿ƒå¹¶æ”¾å¤§
                mesh.position.x = THREE.MathUtils.lerp(startPos.x, 0, ease);
                mesh.position.y = THREE.MathUtils.lerp(startPos.y, 0.5, ease);
                mesh.position.z = THREE.MathUtils.lerp(startPos.z, 4, ease);
                mesh.scale.setScalar(THREE.MathUtils.lerp(startScale, 1.2, ease));

                if (flipProgress < 1) {
                    requestAnimationFrame(flipAnimation);
                } else {
                    gameState.phase = 'SHOWING';
                    showResult();
                }
            }
            flipAnimation();

            statusText.innerText = "çŠ¶æ€: ç¿»å¼€å‘½è¿ä¹‹ç‰Œ...";
        }

        function showResult() {
            const data = gameState.selectedData;
            const isRev = data.isReversed;
            const titleStr = data.name + (isRev ? " (é€†ä½)" : " (æ­£ä½)");
            const meaningStr = isRev ? data.r : data.u;

            // æ˜¾ç¤ºç‰Œå
            const nameReveal = document.getElementById('card-name-reveal');
            nameReveal.textContent = data.name;
            nameReveal.classList.remove('show');
            nameReveal.classList.add('showing');

            // UI æ˜¾ç¤º
            resTitle.innerText = titleStr;
            resTitle.style.color = isRev ? "#aaa" : "#d4af37";
            resSub.innerText = meaningStr;
            resOverlay.style.opacity = 1;

            // å†å²è®°å½•
            const div = document.createElement('div');
            div.className = 'history-item';
            div.innerHTML = `<div class="history-name">${titleStr}</div><div class="history-meaning">${meaningStr}</div>`;
            historyContent.prepend(div);

            statusText.innerText = "çŠ¶æ€: å‘½è¿å·²æ­æ™“! æ¾å¼€æ‹³å¤´ç»§ç»­...";
        }

        // å‡åç‰Œï¼ˆåŸæ¶ˆæ•£é€»è¾‘ï¼‰
        function dismissCard() {
            if (!gameState.selectedMesh) return;

            const mesh = gameState.selectedMesh;
            const idx = gameState.cardMeshes.indexOf(mesh);
            const cardName = gameState.selectedData ? gameState.selectedData.name : '';

            // æ˜¾ç¤ºç‰Œåå‡ååŠ¨ç”»
            const nameReveal = document.getElementById('card-name-reveal');
            nameReveal.textContent = cardName;
            nameReveal.classList.remove('showing');
            nameReveal.classList.remove('show');
            void nameReveal.offsetWidth; // å¼ºåˆ¶é‡ç»˜
            nameReveal.classList.add('show');

            // ç”Ÿæˆæ˜Ÿå…‰å‡åæ•ˆæœ
            starlights.push(new StarlightEffect(mesh.position.clone()));
            scene.remove(mesh);
            if (idx >= 0) gameState.cardMeshes[idx] = null;

            gameState.selectedMesh = null;
            gameState.selectedData = null;
            resOverlay.style.opacity = 0;

            statusText.innerText = "çŠ¶æ€: çµæ„Ÿå‡åï¼Œå‡†å¤‡ä¸‹ä¸€è½®...";

            // 2.5ç§’åé‡æ–°ç”Ÿæˆï¼ˆç­‰å¾…åŠ¨ç”»å®Œæˆï¼‰
            setTimeout(() => {
                nameReveal.classList.remove('show');
                spawnAllCards();
            }, 2500);
        }

        // ==========================================
        // 6. è¾“å…¥å¤„ç†
        // ==========================================

        // é¼ æ ‡æ¨¡å¼
        window.addEventListener('mousemove', (e) => {
            if (gameState.mode !== 'MOUSE') return;
            mouseVector.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouseVector.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });
        window.addEventListener('mousedown', () => {
            if (gameState.mode === 'MOUSE') {
                // æŒ‰ä½ = æ»šåŠ¨
                gameState.isDragging = true;
            }
        });
        window.addEventListener('mouseup', () => {
            if (gameState.mode === 'MOUSE') {
                gameState.isDragging = false;
            }
        });
        window.addEventListener('dblclick', () => {
            if (gameState.mode === 'MOUSE') {
                // åŒå‡»åˆ‡æ¢æ‹³å¤´çŠ¶æ€
                if (gameState.phase === 'SHOWING') {
                    // å±•ç¤ºä¸­åŒå‡» = å‡å
                    gameState.isFist = false;
                    gameState.wasFist = true; // è§¦å‘å‡å
                } else {
                    // æ­£å¸¸åŒå‡» = æŠ½å–
                    gameState.isFist = true;
                    gameState.wasFist = false;
                }
            }
        });

        const modeBtn = document.getElementById('mode-btn');
        modeBtn.addEventListener('click', () => {
            if (gameState.mode === 'HAND') enableMouseMode();
            else location.reload();
        });

        // æ²‰æµ¸æ¨¡å¼
        const immersiveBtn = document.getElementById('immersive-btn');
        immersiveBtn.addEventListener('click', toggleImmersive);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'i' || e.key === 'I') toggleImmersive();
        });

        function toggleImmersive() {
            document.body.classList.toggle('immersive');
        }

        function enableMouseMode() {
            gameState.mode = 'MOUSE';
            modeBtn.innerText = "å½“å‰: é¼ æ ‡ (ç‚¹å‡»åˆ·æ–°åˆ‡å›æ‘„åƒå¤´)";
            guideText.innerText = "ğŸ–± æŒ‰ä½=æ»šåŠ¨ | åŒå‡»=æŠ½å– | å†æ¬¡åŒå‡»=å‡å";
            statusText.innerText = "å·²åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼";
            cursorDebug.style.display = 'none';
        }

        // MediaPipe
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const gestureLabel = document.getElementById('gesture-label');

        function onResults(results) {
            if (gameState.mode !== 'HAND') return;
            document.getElementById('loader').style.display = 'none';

            // ç»˜åˆ¶æ‘„åƒå¤´ç”»é¢å’Œéª¨éª¼
            try {
                if (results.image) {
                    canvasElement.width = results.image.width;
                    canvasElement.height = results.image.height;
                    canvasCtx.save();
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                }

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];

                    // ç»˜åˆ¶éª¨éª¼ (å…¼å®¹å¤„ç†)
                    const connections = window.HAND_CONNECTIONS || (typeof Hands !== 'undefined' ? Hands.HAND_CONNECTIONS : undefined);
                    if (connections) {
                        drawConnectors(canvasCtx, landmarks, connections, { color: '#00FF00', lineWidth: 2 });
                    }
                    drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 1, radius: 3 });

                    const wrist = landmarks[0];

                    // è®¡ç®—æ‰€æœ‰æŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»
                    // landmarks[0] æ˜¯æ‰‹è…•
                    // landmarks[4, 8, 12, 16, 20] åˆ†åˆ«æ˜¯æ‹‡æŒ‡åˆ°å°æŒ‡çš„æŒ‡å°–
                    let tipsDist = 0;
                    const tipIndices = [4, 8, 12, 16, 20];
                    tipIndices.forEach(idx => {
                        tipsDist += Math.hypot(landmarks[idx].x - wrist.x, landmarks[idx].y - wrist.y);
                    });
                    const avgDist = tipsDist / 5;

                    // åŸå§‹æ£€æµ‹é˜ˆå€¼ï¼ˆè°ƒæ•´é˜ˆå€¼æ›´å®¹æ˜“è¯†åˆ«ï¼‰
                    // avgDist < 0.22 åˆ¤å®šä¸ºæ¡æ‹³
                    // avgDist > 0.28 åˆ¤å®šä¸ºå¼ å¼€
                    const rawFist = avgDist < 0.22;
                    const rawOpen = avgDist > 0.28;

                    // ==========================================
                    // åŠ¨æ€é€Ÿåº¦è®¡ç®—é€»è¾‘
                    // ==========================================
                    if (rawOpen) {
                        // æ˜ å°„æ‰‹æŒå¼ å¼€ç¨‹åº¦åˆ°æ»šåŠ¨é€Ÿåº¦
                        // æœ€å°å¼ å¼€é˜ˆå€¼ minOpen = 0.28 (åˆšå¼€å§‹åˆ¤å®šä¸ºå¼ å¼€)
                        // é¢„ä¼°æœ€å¤§å¼ å¼€å€¼ maxOpen = 0.36 (æ ¹æ®å¤šæ•°ç”¨æˆ·åé¦ˆè°ƒæ•´ï¼ŒåŸ0.45å¤ªé«˜)
                        const minOpen = 0.28;
                        const maxOpen = 0.36;

                        // å½’ä¸€åŒ–å¼ å¼€ç¨‹åº¦ (0.0 ~ 1.0)
                        let openness = (avgDist - minOpen) / (maxOpen - minOpen);
                        openness = Math.max(0, Math.min(1, openness)); // é™åˆ¶åœ¨ 0~1 ä¹‹é—´

                        // å°†å¼ å¼€ç¨‹åº¦å­˜å…¥ gameState æ–¹ä¾¿ UI æ˜¾ç¤º
                        gameState.openness = openness;

                        // é€Ÿåº¦èŒƒå›´æ˜ å°„
                        // æœ€å°é€Ÿåº¦ minSpeed = 0.03 (ç¼“æ…¢æ»šåŠ¨)
                        // æœ€å¤§é€Ÿåº¦ maxSpeed = 0.15 (å¿«é€Ÿæ»šåŠ¨)
                        const minSpeed = 0.03;
                        const maxSpeed = 0.15;

                        // çº¿æ€§æ’å€¼è®¡ç®—å½“å‰é€Ÿåº¦
                        gameState.currentSpeed = minSpeed + openness * (maxSpeed - minSpeed);
                    } else {
                        // å¦‚æœæ‰‹æ²¡å¼ å¼€ï¼Œé‡ç½®ä¸ºåŸºç¡€é€Ÿåº¦æˆ–0
                        gameState.currentSpeed = 0;
                        gameState.openness = 0;
                    }

                    // é˜²æŠ–å¤„ç†
                    if (rawFist) {
                        gameState.fistCounter++;
                        gameState.openCounter = 0;
                    } else if (rawOpen) {
                        gameState.openCounter++;
                        gameState.fistCounter = 0;
                    } else {
                        gameState.fistCounter = Math.max(0, gameState.fistCounter - 1);
                        gameState.openCounter = Math.max(0, gameState.openCounter - 1);
                    }

                    // è¾¾åˆ°é˜ˆå€¼æ‰ç¡®è®¤çŠ¶æ€
                    gameState.isFist = gameState.fistCounter >= gameState.gestureThreshold;
                    gameState.isHandOpen = gameState.openCounter >= gameState.gestureThreshold;

                    // æ›´æ–°æ ‡ç­¾
                    if (gameState.isFist) {
                        // å¦‚æœæ­£åœ¨ä¿æŒæ¡æ‹³é€»è¾‘ä¸­ï¼ˆä¸”ä¸åœ¨ç¿»ç‰Œæˆ–å±•ç¤ºé˜¶æ®µï¼‰
                        if (gameState.isHoldingFist && gameState.phase !== 'FLIPPING' && gameState.phase !== 'SHOWING') {
                            const elapsed = Date.now() - gameState.fistHoldStartTime;
                            const remaining = Math.max(0, ((gameState.fistHoldDuration - elapsed) / 1000).toFixed(1));
                            gestureLabel.innerText = `æ£€æµ‹: âœŠ ä¿æŒ ${remaining}s`;
                            gestureLabel.style.color = "orange"; // ä¿æŒè¿‡ç¨‹ä¸­æ˜¾ç¤ºæ©™è‰²
                        } else {
                            gestureLabel.innerText = "æ£€æµ‹: âœŠ æ¡æ‹³ (æŠ½å–)";
                            gestureLabel.style.color = "red";
                        }
                    } else if (gameState.isHandOpen) {
                        gestureLabel.innerText = "æ£€æµ‹: ğŸ– å¼ å¼€ (æ»šåŠ¨)";
                        gestureLabel.style.color = "#0f0";
                    } else {
                        gestureLabel.innerText = "æ£€æµ‹: ...";
                        gestureLabel.style.color = "yellow";
                    }

                    // è°ƒè¯•å…‰æ ‡
                    cursorDebug.style.display = 'block';
                    cursorDebug.style.left = '50%';
                    cursorDebug.style.top = '85%';

                    if (gameState.isFist) {
                        cursorDebug.style.borderColor = 'red';
                        cursorDebug.style.backgroundColor = 'rgba(255,0,0,0.4)';
                        cursorDebug.style.boxShadow = '0 0 20px red';
                    } else if (gameState.isHandOpen) {
                        cursorDebug.style.borderColor = '#0f0';
                        cursorDebug.style.backgroundColor = 'rgba(0,255,0,0.3)';
                        cursorDebug.style.boxShadow = '0 0 20px #0f0';
                    } else {
                        cursorDebug.style.borderColor = 'yellow';
                        cursorDebug.style.backgroundColor = 'transparent';
                        cursorDebug.style.boxShadow = 'none';
                    }
                } else {
                    gameState.isHandOpen = false;
                    gameState.isFist = false;
                    gameState.fistCounter = 0;
                    gameState.openCounter = 0;
                    cursorDebug.style.display = 'none';

                    gestureLabel.innerText = "æœªæ£€æµ‹åˆ°æ‰‹æŒ";
                    gestureLabel.style.color = "#aaa";
                }
                canvasCtx.restore();
            } catch (e) {
                console.error("onResults error:", e);
            }
        }

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 640, height: 480
        });

        cameraUtils.start().then(() => {
            console.log("Camera started");
        }).catch(err => {
            console.error(err);
            document.getElementById('loader').style.display = 'none';
            alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥æˆ–è¢«æ‹’ç»ï¼Œåˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼ã€‚");
            enableMouseMode();
        });

        // ==========================================
        // 7. ä¸»å¾ªç¯
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);
            updateInteraction();

            // æ›´æ–°æ˜Ÿç©ºèƒŒæ™¯
            if (starfield) starfield.update();

            // å®‰å…¨æ›´æ–°æ˜Ÿå…‰ç²’å­
            if (starlights.length > 0) {
                starlights = starlights.filter(s => s.update());
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // å¯åŠ¨è½¬ç›˜
        spawnAllCards();
        animate();

    </script>
</body>

</html>